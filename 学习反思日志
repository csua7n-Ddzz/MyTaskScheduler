## 1. 项目背景与个人状态

作为一名计算机基础相对薄弱的研一学生，面对“多线程”、“防死锁”、“MFC”这些概念，起初我是非常焦虑的。我的编程基础仅限于简单的逻辑控制，对于 C++ 的内存管理、并发机制几乎是一张白纸。这个项目对我来说不仅是一次作业，更是一次填补技术鸿沟的挑战。

## 2. 遇到的核心挑战与解决方案

在开发过程中，我遇到了三个让我印象深刻的“拦路虎”，它们的解决过程构成了我这次项目最大的收获：

* **挑战一：恐怖的中文乱码 (Mojibake)**
* **现象**：日志里全是“锟斤拷”和怪异符号，甚至导致编译报错“未找到匹配令牌”。
* **反思**：我第一次深刻认识到“编码”的复杂性。Visual Studio 默认的 GBK 与现代通用的 UTF-8 经常打架。
* **解决**：在尝试了 BOM 头、`setlocale` 等多种方法后，最彻底的方案竟然是**“回归 ASCII”**——将所有提示语改为英文。这教会我：在工程中，**简单（KISS 原则）往往是最优解**。


* **挑战二：理解“防死锁”**
* **现象**：老师要求有防死锁功能，但我根本不知道死锁长什么样，更不敢写死锁代码去测试。
* **反思**：死锁就像“两个人过独木桥，互不相让”。
* **解决**：通过 AI 的解释，我理解了“**最小临界区**”的概念。原来防死锁不是靠复杂的算法，而是靠良好的代码习惯——**拿完数据赶紧把锁扔了，再去干活**。


* **挑战三：环境依赖 (它在我电脑上能跑...)**
* **现象**：代码里写死了 `D:\Backup`，担心老师电脑没有 D 盘。
* **解决**：学会了使用 `std::filesystem::current_path()`。写代码不能只顾自己爽，要考虑**可移植性 (Portability)**，这是从“写代码”进阶到“写软件”的关键一步。



## 3. AI 协作带来的启示

在这个项目中，Gemini 扮演了我的“全天候导师”。

* **AI 的局限**：AI 并不是万能的。它曾经因为不知道我的 VS 默认配置，导致提供了无法编译的代码（循环依赖问题）。它也无法直接帮我操作 IDE。
* **我的成长**：我不能只做“复制粘贴工程师”。当 AI 给出代码时，我必须强迫自己去理解每一行（比如 `unique_lock` 是干嘛的）。**AI 缩短了写代码的时间，但我必须花更多时间去理解代码背后的逻辑，这样在答辩演示时才能底气十足。**

## 4. 未来展望

通过 Project 3，我不仅掌握了 C++ 多线程的基本用法，更重要的是建立了对“并发编程”的感性认识。
接下来的计划：

1. **脱离 AI 辅助**：尝试自己手写一个简单的生产者-消费者模型，不看现成代码。
2. **深入理论**：补习《操作系统》中关于进程、线程、锁的理论知识，知其然更知其所以然。
3. **坚持记录**：继续保持写技术日志的习惯，把踩过的坑都记录下来。

**自我评价**：虽然起步艰难，但结果圆满。我对 C++ 的恐惧减少了，对解决问题的信心增加了。
