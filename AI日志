### 第一阶段：代码集成与环境配置

**场景**：我基础薄弱，面对部分代码片段不知道如何插入到现有框架中，且环境配置频频报错。

**Q (我)：** 第六步的代码太碎了，我找不到在哪里替换，能给我全部代码吗？还有，为什么报了 77 个关于 `filesystem` 的错误？
**A (AI)：**

* **AI 的帮助**：
1. **全量代码提供**：放弃了局部修改建议，直接提供了 `MyTaskSchedulerDlg.cpp` 和 `TaskEngine.h` 的**全量代码**，让你只需 Ctrl+A 全选替换，降低了操作门槛。
2. **环境诊断**：识别出 `filesystem` 报错是因为 Visual Studio 默认标准过低，指导开启 `/std:c++17` 解决大量报错。


* **AI 的局限**：
1. **无法直接操作**：AI 无法直接帮你点选 VS 的属性配置，只能提供文字步骤，导致你需要手动寻找菜单位置。
2. **依赖预判**：最初提供的代码使用了 C++17 特性，但没有提前预警你需要修改编译器标准，导致你先遇到了报错才进行修复。



---

### 第二阶段：功能实现（从模拟到真实）

**场景**：我觉得用 `sleep` 模拟任务太假，希望实现真实的文件备份和网络请求，但不想修改框架。

**Q (我)：** 按钮 A 没看到文件生成啊？能不能把五个任务都做成真正可实现的，而不是模拟打印日志？
**A (AI)：**

* **AI 的帮助**：
1. **重构任务逻辑**：将 `TaskEngine.h` 中的“模拟代码”替换为“真实代码”。引入了 `URLDownloadToFile` (下载)、`ShellExecute` (弹计算器)、`fs::copy_file` (文件备份)。
2. **策略模式应用**：利用之前设计的策略模式，在不修改 UI 和调度核心的情况下，仅通过替换 `TaskEngine.h` 就实现了功能升级。


* **AI 的局限**：
1. **循环依赖错误**：在尝试编写“Task A 内部调用 AddTask”以验证防死锁时，引发了 `TaskEngine` 与 `TaskScheduler` 的循环引用编译错误。AI 第一次未能预判头文件包含顺序的问题，后续通过移除测试代码才修复。
2. **网络不确定性**：提供的 Github API 请求代码在网络不通时会失败，后来通过增加“断网保护/模拟数据”逻辑才解决了演示风险。



---

### 第三阶段：顽固的乱码问题 (Debug)

**场景**：日志文件里一直显示乱码（Mojibake），尝试了多次修改代码都没好。

**Q (我)：** 日志还是乱码，我删了文件也没用，怎么办？
**A (AI)：**

* **AI 的帮助**：
1. **多方案尝试**：提供了三种方案（写入 BOM 头、强制 `/utf-8` 编译选项、使用 `std::setlocale` 回归系统默认编码）。
2. **最终兜底**：当编码设置过于复杂导致编译器报错（“未找到匹配令牌”）时，果断建议**将提示语改为全英文**。这彻底根除了 GBK/UTF-8 的冲突，保证了便携性。


* **AI 的局限**：
1. **环境黑盒**：AI 看不到你电脑具体的 System Locale 和 VS 的默认编码设置，只能通过“试错法”一步步排查，导致这个问题反复了几个回合才彻底解决。



---

### 第四阶段：核心难点攻关（防死锁）

**场景**：老师要求有防死锁功能，但我不知道怎么体现，也不知道防死锁到底是什么。

**Q (我)：** 没有手动方法体现防死锁吗？怎么向老师演示这个功能？
**A (AI)：**

* **AI 的帮助**：
1. **概念可视化**：用“厕所管理员交出钥匙”的比喻解释了“最小临界区”原理。
2. **演示剧本设计**：设计了“代码审查 (Code Review)”的话术，教你指着 `Execute()` 前的解锁括号进行讲解，而不是冒险运行可能崩溃的测试代码。
3. **区分概念**：纠正了“拖动窗口不卡 = 防死锁”的误区，明确指出“拖动窗口 = 多线程”，“任务重入不卡 = 防死锁”。



---

### 第五阶段：演示与交付

**场景**：需要在老师的电脑上演示，担心环境不同（如没有 D 盘）导致演示翻车。

**Q (我)：** 分析代码，重构以便在其他机器演示，要求结果相同。
