**项目名称**：基于 C++ MFC 的多线程任务调度系统 (MyTaskScheduler)
**开发者**：薛凯元
**开发环境**：Visual Studio 2022, Windows 10/11 SDK, C++17 Standard
**提交日期**：2026年1月8日

---

## 1. 摘要 (Abstract)

随着软件功能的日益复杂，单线程应用程序在处理高负载计算或网络 I/O 时常出现界面卡死（UI Freeze）现象，严重影响用户体验。本项目基于 C++ MFC 框架，设计并实现了一套通用的多线程任务调度系统。系统采用生产者-消费者模型，通过优先队列实现任务的智能调度，并结合 RAII 技术与“最小临界区”策略，从架构层面彻底解决了死锁问题。测试结果表明，该系统能有效分离 UI 线程与工作线程，在执行高并发、高负载任务时保持界面流畅响应。

## 2. 系统设计 (System Design)

### 2.1 核心架构

本系统采用了分层架构设计，主要包含以下模块：

* **UI 层 (View)**: 负责接收用户指令（点击按钮）并将任务请求封装发送给调度器。
* **调度核心 (Controller)**: `TaskScheduler` 类（单例模式）。维护一个线程安全的优先队列，负责任务的排序与分发。
* **执行引擎 (Model)**: `WorkerThread`。后台驻留线程，不断从队列中取出任务并执行。
* **任务策略 (Strategy)**: `ITask` 抽象基类及其派生类（Task A-E），实现了不同业务逻辑的解耦。

### 2.2 关键技术点

1. **多线程并发 (Concurrency)**: 使用 `std::thread` 创建后台工作线程，利用 `std::mutex` 和 `std::condition_variable` 实现线程间的同步与互斥。
2. **死锁预防 (Deadlock Prevention)**:
* **资源获取即初始化 (RAII)**: 全程使用 `std::unique_lock` 管理锁的生命周期，防止异常导致的锁泄露。
* **执行前解锁 (Unlock-before-Execute)**: 在 `WorkerLoop` 中，仅在从队列取任务时持有锁，**在执行具体任务代码前强制释放锁**。这消除了因任务重入（Task 内部再次调用 AddTask）而导致死锁的可能性。


3. **便携性设计 (Portability)**:
* 使用 C++17 `std::filesystem` 动态获取当前运行路径，避免硬编码绝对路径。
* 全英文日志与提示，规避 GBK/UTF-8 编码冲突导致的跨平台乱码问题。



## 3. 功能实现 (Implementation)

本项目成功实现了五类典型任务，验证了调度器的通用性：

* **Task A (文件备份)**: 演示文件 I/O 能力。智能检测磁盘环境，优先备份至 D 盘，若缺失则降级备份至 C 盘或程序运行目录，保证鲁棒性。
* **Task B (矩阵计算)**: 演示 CPU 密集型任务。执行 200x200 高维矩阵乘法，验证在满载计算下 UI 依然流畅（No Freeze）。
* **Task C (网络请求)**: 演示网络 I/O 能力。调用 `URLDownloadToFile` 请求 GitHub API，内置断网保护机制（Fallback Mode），确保演示稳定性。
* **Task D (课堂提醒)**: 演示跨线程 UI 更新。在后台线程安全调用 Win32 API (`MessageBox`) 弹出顶层窗口。
* **Task E (数据统计)**: 演示数学运算与延迟调度。生成随机数计算均值方差，验证优先队列的“插队”机制（延迟任务 vs 立即任务）。

## 4. 总结 (Conclusion)

本项目完成了一个高健壮性的任务调度系统。通过引入多线程机制，解决了传统 MFC 程序界面假死的问题。在开发过程中，重点攻克了“死锁预防”和“环境兼容性”两大难点，最终交付的代码具备良好的可读性与可移植性。
